java 知识点总结
-------------------------------------一、Java概念-----------------------------------------
Java组成：编程语言、计算平台

Java SE(J2SE)(Java2 Platform Standard Edition， Java平台标准版) 
Java EE(J2EE)(Java2 Platform， Enterprise Edition， Java平台企业版)
Java ME(J2ME)(Java2 Platform Micro Edition， Java平台微型版)

Java特点：面向对象（Object Oriented）的编程语言

面向对象概念：现实世界抽象化，把相关数据和方法组织成一个整体

面向过程特征
	以过程为中心，顺序性完成一系列动作

面向对象特征
	1.不用按照固定顺序执行每个动作
	2.不用手动管理对象的生命周期
	3.简单易用和功能强大
	4.静态语言，编译期定义数据类型，执行高效，运行速度快
	5.依赖JVM，平台独立性和可移植性
	6.在用户空间实现多线程，内核无感知
	7.高性能（JVM内嵌的JIT编译器/动态编辑器）

从操作系统的角度来说，实现多线程的几种方式
	在用户空间中实现多线程
	在内核空间中实现多线程
	在用户和内核空间中混合实现多线程

高级编程语言程序执行方式
	1.编译执行：程序语句先通过编译器（负责将一条语句翻译成多条机器指令）翻译成机器指令然后执行
	2.解释执行：程序语句逐条被解释器解释执行，不需要编译成机器指令
	3.编译+解释执行：程序先被编译成字节码文件，然后字节码被解释器解释执行

程序执行步骤
	java代码→字节码(bytecode，javac编译器编译)→机器代码(JVM内嵌解释器将字节码转为机器代码)

JDK(Java Development Kit):Java开发标准工具包，包含JRE

Java运行环境(Java Runtime Environment)：Java运行环境

-------------------------------------二、Java基本语法-----------------------------------------

数据类型
	整数型：
		byte:字节 = 8 bits(位)，默认值0
		short：2字节 = 16 bits，默认值0
		int：4字节 = 32 bits，默认值0
		long：8字节 = 64 bits，默认值0L
		占用空间大小排序：
			byte < short < int < long
	浮点型：
		float：单精度浮点，4字节 = 32 bits，默认值0
		double：双精度浮点，8字节 = 64 bits，默认值0.0d
	字符型：
		char：2字节 = 16 bits(Unicode)，默认值\u000(=0)
	布尔型：
		boolean

逻辑运算符
	&&：短路与
	||：短路或
	！：非
	& ：与
	| ：非
	^ ：异或，转二级制同位比较，相同则0，否为1

位运算符
	&：与，两个操作数中位都为1，结果1，否则0
	|：或，两位只要有一个为1，结果为1，否则0
	~：非，如果位为0，结果为1，如果位为1，结果为0
	^：异或，两位相同为0，不同为1

移位运算符
	<<：左移，将运算符左边对象向左移动右边指定位数（低位补0）
	>>：右移（有符号），将运算符左边对象向右移动右边指定位数（值为正，高位补0；值为负，高位补1）
	>>>：右移（无符号），将运算符左边对象向右移动右边指定位数（无论正负值，高位补0）


-------------------------------------三、面向对象-----------------------------------------
类组成部分
	静态属性：static开头定义的属性
	静态方法快：static{}代码块
	普通属性：属性
	方法快：｛｝代码块
	构造函数：类名相同的方法
	方法：普通方法

初始化顺序
	静态属性初始化 → 静态方法块初始化 → 普通属性初始化 → 普通方法快初始化 → 构造函数初始化

作用域
	作用域决定了其内部定义的变量名的可见性和生命周期

多态
	同一行为具有多个不同的表现形式，指一个类实例（对象）的相同的方法在不同的情形下不同的表现形式
实现多态的条件
	集成
	重写父类的方法
	父类的引用指向子类对象

组合和继承区别
	特征        组合               继承
	关系        has-a             is-a
	耦合度      松耦合             紧耦合
	是否多态    不具备和向上转型    多态基础，可以实现向上转型
	时期        运行期绑定         编译器绑定

向上转型
	通过子类对象（小范围）转化为父类对象(大范围)，自动完成，不用强制
向下转型
	通过父类对象（大范围）实例化子类对象(小范围)，需要强制指定

static
	静态方法没有this关键字



-------------------------------------四、异常-----------------------------------------

Throwable
	Java语言中所有错误(errors)和异常(exceptions)的父类，只有继承于Throwable的类或者其子类才能被抛出，或者带有@throw注解的类

Throwable组成：
	Error
	Exception

Exception组成：
	RuntimeException
	CheckedException

常见异常及其分类
	RuntimeException
		ArrayIndexOutOfBoundsExceptions：数组越界异常
		NullPointerException：空指针异常
		IllegalArgumentException：非法参数异常
		NegativeArraySizeException：数组长度为负异常
		IllegalStateException：非法状态异常
		CLassCastException：类型转换异常
	UncheckedException
		NoSuchFieldException：表示该类没有指定名称抛出来的异常
		NoSuchMethodException：表示该类没有指定方法抛出来的异常
		IllegalAccessException：不允许访问某个类的异常
		CLassNotFoundException：类没有找到抛出来的异常

Java内存模型组成部分
	所有线程共享的数据区：方法区（Method Area）、堆（Heap）
	线程隔离的数据区：虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register）

不会发生内存泄漏(OutOfMemoryError)的区域：
	程序计数器（原理：控制着计算机指令的分支、循环、跳转、异常处理和线程恢复，并且程序计数器每个线程是私有的）
内存泄漏：
	虚拟机栈：
		如果线程请求的栈深度大于虚拟机栈所允许的深度，会出现StackOverflowError
		如果虚拟机动态扩展无法申请到足够的内存，会出现OutOfMemoryError
	本地方法栈：同虚拟机栈
	堆：如果堆中没有内存完成实例分配，并且堆无法扩展时，将抛出OutOfMemoryError
	方法区：方法区无法满足内存需求时，将抛出OutOfMemoryError
	
线程私有
	表示各个线程之间互不影响，独立存储的内存区域

JVM：Java Virtual Machine，Java语言解释器，负责内存的分配（堆栈分配）、回收（GC）、解析class为硬件运行的机器码
JMM：Java Memory Model，定义了JVM在计算机内存（RAM）中的工作方式，线程之间内存刷新的状态，是隶属于JVM的


-------------------------------------五、内部类-----------------------------------------

内部类
	内部类拥有外部类的访问权限
定义内部类的方式
	在方法中定义的内部类（局部内部类）
	定义在作用域内，这个作用域在方法的内部（成员内部类）
	实现了接口的匿名类（匿名内部类）
	匿名类，扩展了非默认构造器的类
	匿名类，执行字段初始化操作
	匿名类，通过实例初始化实现构造


-------------------------------------六、集合-----------------------------------------
顶层接口
	Iterable
		实现此接口允许对象成为for-each循环的目标，是Java中的一种语法糖

	Iterator
		实现此接口能够创建一个轻量级的迭代器，用于安全的遍历元素，移除元素，添加元素
		尽量使用迭代器进行元素的添加和删除

	Collection
		顶层接口，用来定义集合的约定
	Collection三大接口
		List：顶层接口，继承Collection，是ArrayList、LinkedList等集合元素父类
		Set：和List同级，对add、equals、hashCode方法提供了额外的标准
		Queue：用来在处理之前保持元素的访问次序，提供了额外的插入，读取，检查操作

	SortedSet
		继承于Set，使用Comparable对元素进行自然排序或者使用Comparator在创建时对元素提供定制的排序规则，set的迭代器将按照升序元素顺序遍历集合
	Map
		支持key-value的存储对象，key不可重复，每个键最多映射一个值。替代了Dictionary类，Dictionary是一个抽象类而不是接口

ArrayList
	实现List的可扩容数组（动态数组），基于数组实现的，非线程安全，扩容后，数组长度会增加50%
	解决线程安全问题
		Collections.synchronizedList(new ArrayList());
	具有fail-fast快速失败机制，当迭代集合的过程中该集合的结构发生改变的时候，有可能会发生fail-fast，抛出ConcurrentModificationException

Vactor
	基于数组实现，线程安全，内部每个方法上锁，避免线程引起的安全性问题，因为这种同步方式需要的开销比较大，访问效率低于ArrayList，扩容长度后数组会增加一倍

LinkList
	双向链表，允许存储任何元素（包括null），非线程安全
	操作都可以表现为双向性的，索引到链表的操作将遍历从头到尾，视哪个距离近为遍历顺序
	解决线程安全问题
		Collections.synchronizedList(new LinkList());

Stack
	堆栈是我们常说的先入先出（吃了吐）容器，集成了Vactor
	提供了常用的push和pop操作，以及在栈顶peek方法，测试stack是否为空empty方法，寻找与栈顶距离的search方法
	Deque<Integer> stack = new ArrayDeque<>();

HashSet
	Set实现类，由Hash表支持（实际上HashSet是HashMap的一个实例），不能保证集合的迭代顺序，允许null元素，非线程安全，支持fail-fast
	解决线程安全问题
		Collections.synchronizedSet();

TreeSet
	基于TreeMap的NavigableSet实现，自然排序或在创建的时候提供的Comparator进行排序，具体取决于构造函数，非线程安全，支持fail-fast
	此实现为基本操作add，remove和contains提供了log(n)的时间成本
	解决线程安全问题
		Collections.synchronizedSortedSet(new TreeSet());

LinkedHashSet
	是Set接口的Hash表和LinkList的实现，链表定义了元素插入集合的顺序，如果元素重新插入，则插入顺序不会受影响，非线程安全，支持fail-fast
	有两个影响其构成的参数：
		初始容量和加载因子，定义与HashSet完全相同
	选择过高的初始容量值的开销比HashSet小，因为LinkedHashSet的迭代次数不受容量影响
	解决线程安全问题
		Collections.synchronizedSet

PriorityQueue
	AbstractQueue实现类，优先级队列的元素根据自然排序或者通过构造函数时期Comparator排序，不允许有null，非线程安全，支持fail-fast
	队列的头在某种意义上是指定顺序的最后一个元素，队列查找操作：poll，remove，peek和element访问队列头部元素
	优先级队列是无限制的，但具有内部capacity，用于控制队列中储存元素的数组大小
	解决线程安全问题
		PriorityBlockingQueue

HashMap
	利用哈希表原理来储存元素的集合，允许空的key-value键值对，非线程安全，支持fail-fast
	HashMap的实例有两个参数影响其性能：
		初始容量和加载因子
	解决线程安全问题
		Collections.synchronizedMap(new HashMap());

TreeMap
	基于navigableMap实现的红黑树，这个map根据key自然排序存储，或者通过Comparator进行定制排序，非线程安全，支持fail-fast
	TreeMap为containsKey，get，put，remove方法提供log(n)的时间开销
	解决线程安全问题
		SortedMap map = Collections.synchronizedSortedMap(new TreeMap());

LinkedHashMap
	是Map接口的Hash表和链表的实现，与HashMap不同之处在于它维护了贯穿了所有条目的双向链表，定义了遍历顺序，通常时插入map的顺序，非线程安全，支持fail-fast
	提供一个特殊的LinkedHashMap(int,float,boolean)构造器来创建LinkedHashMap，其遍历顺序是最后一次访问的顺序
	可以重写removeEldesEntry(Map.Entry)方法，以便在新映射添加到map时强制删除过期映射的策略
	允许null元素，由于维护链表的额外开销，性能可能会低于HashMap（例外：LinkedHashMap的collection-view需要与map.size成正比，无论其容量如何）
	解决线程安全问题
		Map map = Collections.synchronizedMap(new LinkedHashMap());

Hashtable
	实现了一个哈希表，能够将键映射到值，任何非空对象都可以用作键或值，此实现类支持fail-fast

IdentityHashMap
	无序，非线程安全，支持fail-fast
	解决线程安全问题
		Collections.synchronizedMap(new IdentityHashMap());

WeakHashMap
	基于哈希表的Map基础实现，带有弱键。WeakHashMap中的entry当不再使用时会自动移除（给定key的映射的存在将不会阻止key被垃圾收集器丢弃）
	支持null键和null值，不允许重复，支持faill-fast
	WeakHashMap经常用作缓存

Collections
	不属于Java框架继承树上的内容，属于独立的分支，Collections是一个包装器，为集合框架提供某些功能实现，此类只包括静态方法实现或者返回collections

	同步包装
		同步包装器将自动同步（线程安全性）添加到任意集合

	不可修改的包装
		不可修改的包装器通过拦截修改集合的操作并抛出UnSupportedOperationException
		应用场景
			构建集合后使其不变。在这种情况下，最好不要去获取返回collection的引用，这样有利于保证不变性
			允许某些客户端以只读的方式访问你的数据结构。保留对返回的collection的引用，但分发对包装器的引用。通过这种方式，客户可以查看但不能修改，同时保持完全访问权限
		方法
			public static Collection unmodifiableCollection(Collection<? extends T> c);
			public static Set unmodifiableSet(Set<? extends T> s);
			public static List unmodifiableList(List<? extends T> l);
			public static Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m);
			public static SortedSet unmodifiableSortedSet(SortedSet<? extends T> s);
			public static SortedMap<K, V> unmodifiableSortedMap(SortedMap<? extends K, ? extends V> m);

CopyOnWrite
	写时复制的容器，往一个容器添加元素的时候，当前容器进行copy，复制出一个新的容器，然后新的容器添加元素，添加完成后，再将元容器的引用指向新容器（读写分离的思想）


-------------------------------------七、引用-----------------------------------------

强引用（强可达）
	对象刚被创、初始化、使用中的对象都是出于强可达状态
	当内存空间不足，Java虚拟机宁愿抛出OOM（OutOfMemoryError）错误，使程序异常终止，也不会回收这种对象
	中断强引用
		将引用设置为null
		数组.clear()

软引用（软可达）
	用来描述一些有用但并不是必须的对象，用java.lang.ref.SoftReference类表示
	对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象
	应用场景
		网页缓存、图片缓存
	软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象呗JVM回收，这个软引用就会被加入到与之关联的引用队列中

弱引用（弱可达）
	用来描述非必须对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。用java.lang.ref.WeakReference类表示

	弱引用和软引用区别
		只具有弱引用的对象具有更短的生命周期
		被软引用关联的对象只有在内存不足时才会被回收，被弱引用关联的对象在JVM进行垃圾回收时总会被回收

虚引用（幻想可达）
	不影响对象的生命周期，在java.lang.ref.PhantomReference类表示
	如果一个对象与虚引用关联。则跟没有引用关联一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动
	虚引用必须和引用队列关联使用



